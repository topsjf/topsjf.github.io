import{_ as t,V as e,W as r,a0 as p,$ as a}from"./framework-ed4f969a.js";const i="/assets/true-clip_image002-4a08702a.jpg",n="/assets/true-clip_image004-ad8577bf.jpg",s="/assets/true-clip_image006-35321afd.jpg",o="/assets/true-clip_image008-45bada5a.jpg",d="/assets/true-clip_image010-b90d74f6.jpg",g="/assets/true-clip_image012-4c61f4e6.jpg",u="/assets/true-clip_image014-10cdac4b.jpg",c="/assets/true-clip_image016-c5e8c48b.jpg",l={},h=a('<h2 id="spring-cloud-的几大组件" tabindex="-1"><a class="header-anchor" href="#spring-cloud-的几大组件" aria-hidden="true">#</a> spring cloud 的几大组件</h2><table><thead><tr><th>组件</th><th>名称</th></tr></thead><tbody><tr><td>分布式系统套件版本</td><td>Spring Cloud + Alibaba</td></tr><tr><td>服务注册与发现</td><td>Eureka / Consul / Nacos</td></tr><tr><td>配置中心</td><td>Config / Nacos</td></tr><tr><td>网关路由</td><td>Gateway / Zull (动态网关)</td></tr><tr><td>服务调用</td><td>OpenFeign（推荐） / RestTemplate（使用繁琐、冗余，不推荐）</td></tr><tr><td>负载均衡</td><td>LoadBalancer / Ribbon / Nginx</td></tr><tr><td>流量控制</td><td>Sentinel / Hystrix (限流、熔断降级、负载保护)</td></tr><tr><td>分布式事务</td><td>Seata / TX-LCN (可选组件)</td></tr><tr><td>链路追踪</td><td>Sleuth + Zipkin (可选组件)</td></tr><tr><td>工作流引擎框架</td><td>Flowable (可选组件)</td></tr><tr><td>分布式定时任务</td><td>xxl-job (可选组件)</td></tr></tbody></table><h2 id="spring-cloud-基础流程" tabindex="-1"><a class="header-anchor" href="#spring-cloud-基础流程" aria-hidden="true">#</a> Spring cloud 基础流程</h2><p>Eureka</p><p><strong>作用</strong>：服务注册中心，服务发现与注册</p><p><strong>原理</strong>：通过心跳检测、健康检查和客户端缓存等机制</p><p><strong>高可用说明</strong>：eureka可以把自己设置为一个应用程序到自己和其他节点相互注册，这样当一个节点挂掉后，另一个eureka节点就会代替该节点。</p><p><strong>注意</strong>：注册eureka，要同时写多个地址。因为防止eureka挂掉，然后serviceA挂掉，然后serviceA重启，这时候其他服务就访问不到。</p><hr><p>Zuul网关（负载均衡功能）</p><p>将服务保留的rest进行代理和网关控制，除了平常经常使用的node.js、nginx外，Spring Cloud系列的zuul和rebbion，可以帮我们进行正常的网关管控和负载均衡。</p><p>Zuul过滤器</p><p>四种过滤器类型</p><blockquote><p>（1） PRE：过滤器在请求被路由之前调用，可以利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</p><p>（2） ROUTING：过滤器请求理由到微服务。可以用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务</p><p>（3） POST：过滤器到微服务后执行。可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</p><p>（4） ERROR：在其他阶段发生错误时执行该过滤器。</p></blockquote><hr><p>Feign：相当于一个HttpClient的东西，会保持长连接和监控线程池。它可以默认自己包下的Retryer进行重试配置，默认为5次</p><hr><p>Ribbion：相当于是从eureka中获取所有的微服务列表，然后从例如A服务有两个节点，会根据算法选择一个让Feign进行调用。</p><hr><p>Nginx实现反向代理和负载均衡</p><blockquote><p><strong>正向代理</strong>：客户机指定代理服务器，将本要直接发送到Web服务器上的Http请求发送到代理服务器中由代理服务器向internet上的web服务器发送请求，达到客户机上网的目的。</p></blockquote><blockquote><p><strong>反向代理</strong>：指以代理服务器接受internet上的连接请求，然后将请求转发给内部网上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个代理服务器。如图所示：</p></blockquote><p><img src="'+i+'" alt="img"></p><p>Nginx只做请求的转发，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后面的服务器，决定把请求转发给谁。</p><hr><h2 id="springcloud底层服务之间怎么相互调用" tabindex="-1"><a class="header-anchor" href="#springcloud底层服务之间怎么相互调用" aria-hidden="true">#</a> SpringCloud底层服务之间怎么相互调用</h2><p>核心组件：Eureka、Ribbon、Feign、Hystrix、Zuul</p><p>从业务场景入手：开发个电商网站，需要实现支付订单的功能。流程如下：</p><p>² 创建一个订单后，如果用户立刻支付这个订单，我们需要将订单状态更新为“已支付”</p><p>² 扣减相应的商品库存</p><p>² 通知仓储中心，进行发货</p><p>² 给用户的这次购物增加相应的积分</p><p>以上流程，我们需要有订单服务、库存服务、仓储服务、积分服务。</p><p><img src="'+n+'" alt="img"></p><h2 id="一、eureka、nacos" tabindex="-1"><a class="header-anchor" href="#一、eureka、nacos" aria-hidden="true">#</a> 一、Eureka、nacos</h2><p>订单服务想要调用库存服务、仓储服务或者积分服务怎么调用？</p><p><img src="'+s+'" alt="img"></p><p>每个服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中，自己在哪台机器上，监听哪个端口。Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号。</p><p>订单服务中有一个Eureka Client组件，这个会找Server问一下：库存服务在哪台机器？监听着哪个端口，然后把相关信息从注册表中拉取到本地缓存起来。</p><p>这时，想要进行服务之间的调用，只需要找自己本地的Eureka Client问一下在哪台机器？哪个端口？收到响应后，紧接着就可以发送一个请求过去，调用接口！</p><p>总结：</p><p>​ Eureka Client：负责将这个服务的信息注册到Eureka Server中。</p><p>​ Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</p><h2 id="二、openfeign" tabindex="-1"><a class="header-anchor" href="#二、openfeign" aria-hidden="true">#</a> 二、OpenFeign</h2><p>知道端口号后，<strong>难道订单服务要自己写一堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理？</strong></p><p>J Feign是一个关键机制使用了动态代理。</p><p>J 首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</p><p>J 接着你要调用哪个接口，本质就是会调用Feign创建的动态代理，这个就是核心</p><p>J Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务地址</p><p>J 最后根据这个地址，发起请求、解析响应</p><p><img src="'+o+'" alt="img"></p><h2 id="三、ribbon、nginx" tabindex="-1"><a class="header-anchor" href="#三、ribbon、nginx" aria-hidden="true">#</a> 三、Ribbon、Nginx</h2><p>如果库存服务上部署在了5台机器上，Feign怎么请求哪台机器？</p><p>Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法，简单说就是订单服务对库存服务发起10次请求，那就让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器，第5台机器，接着又继续循环。</p><p>J 首先Ribbon会从Eureka Client里获取到对应的服务注册表，也就知道所有的服务都部署在哪些机器上，在监听哪些端口号。</p><p>J 然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</p><p>J Feign就会针对这台机器，构造并发起请求。</p><p><img src="'+d+'" alt="img"></p><h2 id="四、hystrix" tabindex="-1"><a class="header-anchor" href="#四、hystrix" aria-hidden="true">#</a> 四、Hystrix</h2><p>订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后，积分服务挂掉了，每次订单服务调用积分服务时候，都会卡住几秒钟，然后抛出一个超时异常。</p><p>如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程就会卡在请求积分服务这一块，导致订单服务没有一个线程可以处理请求。</p><p>然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求</p><p>这就是微服务了中的服务雪崩问题</p><p><img src="'+g+'" alt="img"></p><p>Hystrix是隔离、熔断以及降级的一个框架。即Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求积分服务又是一个线程池。每个线程池仅仅用于请求那个服务。</p><p>熔断：比如在5分钟内请求积分服务直接就返回了，不要去走网络卡几秒钟，这个过程就是熔断。</p><p>降级：每次调用积分服务，就在数据库中记录一条消息，说给某某用户增加多少积分，因为积分服务挂掉，所以增加不成功，等积分服务恢复了，你可以根据这些记录手工加以下积分。</p><p><img src="'+u+'" alt="img"></p><h2 id="五、zuul、gateway" tabindex="-1"><a class="header-anchor" href="#五、zuul、gateway" aria-hidden="true">#</a> 五、Zuul、Gateway</h2><p>微服务网关，这个是负责网络路由的。</p><p>假设你后台部署了几百个服务，现在有个前端的小姐姐，人家请求是直接从浏览器哪儿发过来的。 人家要请求库存服务，你难道还要让人家记着这服务的名字叫做xxxxxx？部署在5台机器上，你后台可是有几百个服务的名称和地址？难道都需要一个一个记着？</p><p>所有的请求都可以走网关，网关还有许多好处：统一的降级、限流、认证授权、安全、等等。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><strong>Eureka、Nacos</strong>：（注册中心）各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</p><p><strong>Ribbon、nginx</strong>：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</p><p><strong>Feign</strong>：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</p><p><strong>Hystrix</strong>：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p><p><strong>Zuul、Gateway</strong>：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</p><p><img src="'+c+'" alt="img"></p>',79);function b(m,x){return e(),r("div",null,[p(" more "),h])}const k=t(l,[["render",b],["__file","spring-cloud-core-components.html.vue"]]);export{k as default};
