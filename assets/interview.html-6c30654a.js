const l=JSON.parse('{"key":"v-e6739e42","path":"/all/interview.html","title":"Java面试宝典","lang":"zh-CN","frontmatter":{"icon":"java","title":"Java面试宝典","category":["面试宝典"],"date":"2022-07-21T00:00:00.000Z","tag":["Java"],"description":"Java面向对象有哪些特征，如何应用 面向对象编程是利用类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物。 面向对象的三大特征封装，继承，多态。 1) 封装说明一个类行为和属性与其他类的关系，...","head":[["meta",{"property":"og:url","content":"https://topjf.github.io/all/interview.html"}],["meta",{"property":"og:site_name","content":"topjf"}],["meta",{"property":"og:title","content":"Java面试宝典"}],["meta",{"property":"og:description","content":"Java面向对象有哪些特征，如何应用 面向对象编程是利用类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物。 面向对象的三大特征封装，继承，多态。 1) 封装说明一个类行为和属性与其他类的关系，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://topjf.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-12-16T06:02:03.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Java面试宝典"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-07-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-12-16T06:02:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java面试宝典\\",\\"image\\":[\\"https://topjf.github.io/\\"],\\"datePublished\\":\\"2022-07-21T00:00:00.000Z\\",\\"dateModified\\":\\"2022-12-16T06:02:03.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Java面向对象有哪些特征，如何应用","slug":"java面向对象有哪些特征-如何应用","link":"#java面向对象有哪些特征-如何应用","children":[]},{"level":2,"title":"HashMap原理是什么，在jdk1.7和1.8中有什么区别","slug":"hashmap原理是什么-在jdk1-7和1-8中有什么区别","link":"#hashmap原理是什么-在jdk1-7和1-8中有什么区别","children":[]},{"level":2,"title":"ArrayList和LinkedList有什么区别？","slug":"arraylist和linkedlist有什么区别","link":"#arraylist和linkedlist有什么区别","children":[]},{"level":2,"title":"高并发中的集合有哪些问题","slug":"高并发中的集合有哪些问题","link":"#高并发中的集合有哪些问题","children":[]},{"level":2,"title":"jdk1.8的新特性有哪些","slug":"jdk1-8的新特性有哪些","link":"#jdk1-8的新特性有哪些","children":[{"level":3,"title":"一、接口的默认方法","slug":"一、接口的默认方法","link":"#一、接口的默认方法","children":[]},{"level":3,"title":"二、Lambda 表达式","slug":"二、lambda-表达式","link":"#二、lambda-表达式","children":[]},{"level":3,"title":"三、函数式接口","slug":"三、函数式接口","link":"#三、函数式接口","children":[]},{"level":3,"title":"四、方法与构造函数引用","slug":"四、方法与构造函数引用","link":"#四、方法与构造函数引用","children":[]},{"level":3,"title":"五、Lambda 作用域","slug":"五、lambda-作用域","link":"#五、lambda-作用域","children":[]},{"level":3,"title":"六、访问局部变量","slug":"六、访问局部变量","link":"#六、访问局部变量","children":[]},{"level":3,"title":"七、访问对象字段与静态变量","slug":"七、访问对象字段与静态变量","link":"#七、访问对象字段与静态变量","children":[]},{"level":3,"title":"八、访问接口的默认方法","slug":"八、访问接口的默认方法","link":"#八、访问接口的默认方法","children":[]},{"level":3,"title":"九、Date API","slug":"九、date-api","link":"#九、date-api","children":[]},{"level":3,"title":"十、Annotation 注解","slug":"十、annotation-注解","link":"#十、annotation-注解","children":[]}]},{"level":2,"title":"Java中重写和重载有哪些区别","slug":"java中重写和重载有哪些区别","link":"#java中重写和重载有哪些区别","children":[]},{"level":2,"title":"接口和抽象类有哪些区别","slug":"接口和抽象类有哪些区别","link":"#接口和抽象类有哪些区别","children":[]},{"level":2,"title":"怎样声明一个类不会被继承，什么场景下会用","slug":"怎样声明一个类不会被继承-什么场景下会用","link":"#怎样声明一个类不会被继承-什么场景下会用","children":[]},{"level":2,"title":"Java中==和equals有哪些区别","slug":"java中-和equals有哪些区别","link":"#java中-和equals有哪些区别","children":[]},{"level":2,"title":"String、StringBuffer、StringBuilder区别及使用场景","slug":"string、stringbuffer、stringbuilder区别及使用场景","link":"#string、stringbuffer、stringbuilder区别及使用场景","children":[]},{"level":2,"title":"Java代理的几种实现方式","slug":"java代理的几种实现方式","link":"#java代理的几种实现方式","children":[{"level":3,"title":"Proxy代理是JDK内置的动态代理","slug":"proxy代理是jdk内置的动态代理","link":"#proxy代理是jdk内置的动态代理","children":[]},{"level":3,"title":"CGLIB动态代理","slug":"cglib动态代理","link":"#cglib动态代理","children":[]}]},{"level":2,"title":"hashcode和equals如何使用","slug":"hashcode和equals如何使用","link":"#hashcode和equals如何使用","children":[]},{"level":2,"title":"HashMap和HashTable的区别及底层实现`","slug":"hashmap和hashtable的区别及底层实现","link":"#hashmap和hashtable的区别及底层实现","children":[{"level":3,"title":"HashMap和HashTable对比","slug":"hashmap和hashtable对比","link":"#hashmap和hashtable对比","children":[]},{"level":3,"title":"HashMap扩容优化:","slug":"hashmap扩容优化","link":"#hashmap扩容优化","children":[]},{"level":3,"title":"为什么hashmap扩容的时候是两倍？","slug":"为什么hashmap扩容的时候是两倍","link":"#为什么hashmap扩容的时候是两倍","children":[]},{"level":3,"title":"hashmap线程安全的方式？","slug":"hashmap线程安全的方式","link":"#hashmap线程安全的方式","children":[]}]},{"level":2,"title":"Java异常处理方式","slug":"java异常处理方式","link":"#java异常处理方式","children":[{"level":3,"title":"throw和throws的区别","slug":"throw和throws的区别","link":"#throw和throws的区别","children":[]},{"level":3,"title":"1.throws声明异常","slug":"_1-throws声明异常","link":"#_1-throws声明异常","children":[]},{"level":3,"title":"2.throw抛出异常","slug":"_2-throw抛出异常","link":"#_2-throw抛出异常","children":[]},{"level":3,"title":"3.trycatch捕获异常","slug":"_3-trycatch捕获异常","link":"#_3-trycatch捕获异常","children":[]}]},{"level":2,"title":"自定义异常在生产中如何应用","slug":"自定义异常在生产中如何应用","link":"#自定义异常在生产中如何应用","children":[]},{"level":2,"title":"如何实现一个IOC容器?","slug":"如何实现一个ioc容器","link":"#如何实现一个ioc容器","children":[]},{"level":2,"title":"说说你对Spring 的理解？","slug":"说说你对spring-的理解","link":"#说说你对spring-的理解","children":[]},{"level":2,"title":"你觉得Spring的核心是什么？","slug":"你觉得spring的核心是什么","link":"#你觉得spring的核心是什么","children":[]},{"level":2,"title":"说一下使用spring的优势？","slug":"说一下使用spring的优势","link":"#说一下使用spring的优势","children":[]},{"level":2,"title":"Spring是如何简化开发的？","slug":"spring是如何简化开发的","link":"#spring是如何简化开发的","children":[]},{"level":2,"title":"Spring AOP的几种通知类型？","slug":"spring-aop的几种通知类型","link":"#spring-aop的几种通知类型","children":[]},{"level":2,"title":"获取方法的返回值可以用哪几种通知？","slug":"获取方法的返回值可以用哪几种通知","link":"#获取方法的返回值可以用哪几种通知","children":[]},{"level":2,"title":"说说你对Aop的理解？","slug":"说说你对aop的理解","link":"#说说你对aop的理解","children":[]},{"level":2,"title":"说说你对IOC的理解？","slug":"说说你对ioc的理解","link":"#说说你对ioc的理解","children":[]},{"level":2,"title":"BeanFactory和ApplicationContext有什么区别","slug":"beanfactory和applicationcontext有什么区别","link":"#beanfactory和applicationcontext有什么区别","children":[]},{"level":2,"title":"简述spring bean的生命周期？","slug":"简述spring-bean的生命周期","link":"#简述spring-bean的生命周期","children":[]},{"level":2,"title":"spring支持的bean作用域有哪些？","slug":"spring支持的bean作用域有哪些","link":"#spring支持的bean作用域有哪些","children":[]},{"level":2,"title":"Spring框架中的单例Bean是线程安全的么？","slug":"spring框架中的单例bean是线程安全的么","link":"#spring框架中的单例bean是线程安全的么","children":[]},{"level":2,"title":"spring框架中使用了哪些设计模式及应用场景","slug":"spring框架中使用了哪些设计模式及应用场景","link":"#spring框架中使用了哪些设计模式及应用场景","children":[]},{"level":2,"title":"spring事务的实现方式原理是什么？","slug":"spring事务的实现方式原理是什么","link":"#spring事务的实现方式原理是什么","children":[]},{"level":2,"title":"脏读、不可重复读、虚读（幻读）","slug":"脏读、不可重复读、虚读-幻读","link":"#脏读、不可重复读、虚读-幻读","children":[]},{"level":2,"title":"spring事务的隔离级别有哪些？","slug":"spring事务的隔离级别有哪些","link":"#spring事务的隔离级别有哪些","children":[]},{"level":2,"title":"spring的事务传播机制是什么？","slug":"spring的事务传播机制是什么","link":"#spring的事务传播机制是什么","children":[]},{"level":2,"title":"spring事务什么时候会失效？","slug":"spring事务什么时候会失效","link":"#spring事务什么时候会失效","children":[]},{"level":2,"title":"什么的是bean的自动装配，它有哪些方式？","slug":"什么的是bean的自动装配-它有哪些方式","link":"#什么的是bean的自动装配-它有哪些方式","children":[]},{"level":2,"title":"spring、springmvc、springboot的区别是什么？","slug":"spring、springmvc、springboot的区别是什么","link":"#spring、springmvc、springboot的区别是什么","children":[]},{"level":2,"title":"springmvc工作流程是什么？","slug":"springmvc工作流程是什么","link":"#springmvc工作流程是什么","children":[]},{"level":2,"title":"springmvc的九大组件有哪些？","slug":"springmvc的九大组件有哪些","link":"#springmvc的九大组件有哪些","children":[]},{"level":2,"title":"springboot自动配置原理是什么？","slug":"springboot自动配置原理是什么","link":"#springboot自动配置原理是什么","children":[]},{"level":2,"title":"如何理解springboot中的starter？","slug":"如何理解springboot中的starter","link":"#如何理解springboot中的starter","children":[]},{"level":2,"title":"什么是嵌入式服务器，为什么使用嵌入式服务器？","slug":"什么是嵌入式服务器-为什么使用嵌入式服务器","link":"#什么是嵌入式服务器-为什么使用嵌入式服务器","children":[]},{"level":2,"title":"mybatis的优缺点有哪些？","slug":"mybatis的优缺点有哪些","link":"#mybatis的优缺点有哪些","children":[]},{"level":2,"title":"mybatis和hibernate有什么区别？","slug":"mybatis和hibernate有什么区别","link":"#mybatis和hibernate有什么区别","children":[]},{"level":2,"title":"mybatis中#{}和${}的区别是什么？","slug":"mybatis中-和-的区别是什么","link":"#mybatis中-和-的区别是什么","children":[]},{"level":2,"title":"简述一下mybatis插件运行原理及开发流程？","slug":"简述一下mybatis插件运行原理及开发流程","link":"#简述一下mybatis插件运行原理及开发流程","children":[]},{"level":2,"title":"mysql聚簇和非聚簇索引的区别是什么？","slug":"mysql聚簇和非聚簇索引的区别是什么","link":"#mysql聚簇和非聚簇索引的区别是什么","children":[]},{"level":2,"title":"mysql索引结构有哪些，各自的优劣是什么？","slug":"mysql索引结构有哪些-各自的优劣是什么","link":"#mysql索引结构有哪些-各自的优劣是什么","children":[]},{"level":2,"title":"索引的设计原则有哪些？","slug":"索引的设计原则有哪些","link":"#索引的设计原则有哪些","children":[]},{"level":2,"title":"mysql锁的类型有哪些？","slug":"mysql锁的类型有哪些","link":"#mysql锁的类型有哪些","children":[]},{"level":2,"title":"mysql执行计划怎么看？","slug":"mysql执行计划怎么看","link":"#mysql执行计划怎么看","children":[]},{"level":2,"title":"事务的基本特性是什么？","slug":"事务的基本特性是什么","link":"#事务的基本特性是什么","children":[]},{"level":2,"title":"MySQL的隔离级别有哪些？","slug":"mysql的隔离级别有哪些","link":"#mysql的隔离级别有哪些","children":[]},{"level":2,"title":"怎么处理MySQL的慢查询？","slug":"怎么处理mysql的慢查询","link":"#怎么处理mysql的慢查询","children":[]},{"level":2,"title":"ACID是靠什么保证的？","slug":"acid是靠什么保证的","link":"#acid是靠什么保证的","children":[]},{"level":2,"title":"什么是MVCC？","slug":"什么是mvcc","link":"#什么是mvcc","children":[]},{"level":2,"title":"MVCC解决的问题是什么？","slug":"mvcc解决的问题是什么","link":"#mvcc解决的问题是什么","children":[]},{"level":2,"title":"MVCC实现原理是什么？","slug":"mvcc实现原理是什么","link":"#mvcc实现原理是什么","children":[]},{"level":2,"title":"什么是mysql的主从复制？","slug":"什么是mysql的主从复制","link":"#什么是mysql的主从复制","children":[]},{"level":2,"title":"mysql为什么需要主从同步？","slug":"mysql为什么需要主从同步","link":"#mysql为什么需要主从同步","children":[]},{"level":2,"title":"mysql复制原理是什么？","slug":"mysql复制原理是什么","link":"#mysql复制原理是什么","children":[]},{"level":2,"title":"简述Myisam和Innodb的区别？","slug":"简述myisam和innodb的区别","link":"#简述myisam和innodb的区别","children":[]},{"level":2,"title":"简述mysql中索引类型有哪些，以及对数据库的性能的影响？","slug":"简述mysql中索引类型有哪些-以及对数据库的性能的影响","link":"#简述mysql中索引类型有哪些-以及对数据库的性能的影响","children":[]},{"level":2,"title":"什么是字节码？","slug":"什么是字节码","link":"#什么是字节码","children":[]},{"level":2,"title":"字节码的组成结构是什么？","slug":"字节码的组成结构是什么","link":"#字节码的组成结构是什么","children":[]},{"level":2,"title":"class初始化过程是什么？","slug":"class初始化过程是什么","link":"#class初始化过程是什么","children":[]},{"level":2,"title":"JVM内存模型如何分配的？","slug":"jvm内存模型如何分配的","link":"#jvm内存模型如何分配的","children":[]},{"level":2,"title":"JVM性能调优的原则有哪些？","slug":"jvm性能调优的原则有哪些","link":"#jvm性能调优的原则有哪些","children":[]},{"level":2,"title":"什么情况下需要JVM调优？","slug":"什么情况下需要jvm调优","link":"#什么情况下需要jvm调优","children":[]},{"level":2,"title":"在JVM调优时，你关注哪些指标？","slug":"在jvm调优时-你关注哪些指标","link":"#在jvm调优时-你关注哪些指标","children":[]},{"level":2,"title":"JVM常用参数有哪些？","slug":"jvm常用参数有哪些","link":"#jvm常用参数有哪些","children":[]},{"level":2,"title":"JVM常用性能调优工具有哪些？","slug":"jvm常用性能调优工具有哪些","link":"#jvm常用性能调优工具有哪些","children":[]},{"level":2,"title":"线上排查问题的一般流程是怎么样的？","slug":"线上排查问题的一般流程是怎么样的","link":"#线上排查问题的一般流程是怎么样的","children":[]},{"level":2,"title":"什么情况下，会抛出OOM呢？","slug":"什么情况下-会抛出oom呢","link":"#什么情况下-会抛出oom呢","children":[]},{"level":2,"title":"系统OOM之前都有哪些现象？","slug":"系统oom之前都有哪些现象","link":"#系统oom之前都有哪些现象","children":[]},{"level":2,"title":"如何进行堆Dump文件分析？","slug":"如何进行堆dump文件分析","link":"#如何进行堆dump文件分析","children":[]},{"level":2,"title":"如何进行GC日志分析？","slug":"如何进行gc日志分析","link":"#如何进行gc日志分析","children":[]},{"level":2,"title":"线上死锁是如何排查的？","slug":"线上死锁是如何排查的","link":"#线上死锁是如何排查的","children":[]},{"level":2,"title":"线上YGC耗时过长优化方案有哪些？","slug":"线上ygc耗时过长优化方案有哪些","link":"#线上ygc耗时过长优化方案有哪些","children":[]},{"level":2,"title":"线上频繁FullGC优化方案有哪些？","slug":"线上频繁fullgc优化方案有哪些","link":"#线上频繁fullgc优化方案有哪些","children":[]},{"level":2,"title":"如何进行线上堆外内存泄漏的分析？（Netty尤其居多）","slug":"如何进行线上堆外内存泄漏的分析-netty尤其居多","link":"#如何进行线上堆外内存泄漏的分析-netty尤其居多","children":[]},{"level":2,"title":"线上元空间内存泄露优化方案有哪些？","slug":"线上元空间内存泄露优化方案有哪些","link":"#线上元空间内存泄露优化方案有哪些","children":[]},{"level":2,"title":"java类加载器有哪些？","slug":"java类加载器有哪些","link":"#java类加载器有哪些","children":[]},{"level":2,"title":"双亲委派机制是什么？","slug":"双亲委派机制是什么","link":"#双亲委派机制是什么","children":[]},{"level":2,"title":"GC如何判断对象可以被回收？","slug":"gc如何判断对象可以被回收","link":"#gc如何判断对象可以被回收","children":[]},{"level":2,"title":"如何回收内存对象，有哪些回收算法？","slug":"如何回收内存对象-有哪些回收算法","link":"#如何回收内存对象-有哪些回收算法","children":[]},{"level":2,"title":"jvm有哪些垃圾回收器，实际中如何选择？","slug":"jvm有哪些垃圾回收器-实际中如何选择","link":"#jvm有哪些垃圾回收器-实际中如何选择","children":[]},{"level":2,"title":"JVM8为什么要增加元空间？","slug":"jvm8为什么要增加元空间","link":"#jvm8为什么要增加元空间","children":[]},{"level":2,"title":"JVM8中元空间有哪些特点？","slug":"jvm8中元空间有哪些特点","link":"#jvm8中元空间有哪些特点","children":[]},{"level":2,"title":"如何解决线上gc频繁的问题？","slug":"如何解决线上gc频繁的问题","link":"#如何解决线上gc频繁的问题","children":[]},{"level":2,"title":"内存溢出的原因有哪些，如何排查线上问题？","slug":"内存溢出的原因有哪些-如何排查线上问题","link":"#内存溢出的原因有哪些-如何排查线上问题","children":[]},{"level":2,"title":"Happens-Before规则是什么？","slug":"happens-before规则是什么","link":"#happens-before规则是什么","children":[]},{"level":2,"title":"介绍一下线程的生命周期及状态？","slug":"介绍一下线程的生命周期及状态","link":"#介绍一下线程的生命周期及状态","children":[]},{"level":2,"title":"线程的sleep、wait、join、yield如何使用？","slug":"线程的sleep、wait、join、yield如何使用","link":"#线程的sleep、wait、join、yield如何使用","children":[]},{"level":2,"title":"创建线程有哪些方式？","slug":"创建线程有哪些方式","link":"#创建线程有哪些方式","children":[]},{"level":2,"title":"什么是守护线程？","slug":"什么是守护线程","link":"#什么是守护线程","children":[]},{"level":2,"title":"ThreadLocal的原理是什么，使用场景有哪些？","slug":"threadlocal的原理是什么-使用场景有哪些","link":"#threadlocal的原理是什么-使用场景有哪些","children":[]},{"level":2,"title":"ThreadLocal有哪些内存泄露问题，如何避免？","slug":"threadlocal有哪些内存泄露问题-如何避免","link":"#threadlocal有哪些内存泄露问题-如何避免","children":[]},{"level":2,"title":"为什么要使用线程池？","slug":"为什么要使用线程池","link":"#为什么要使用线程池","children":[]},{"level":2,"title":"线程池线程复用的原理是什么？","slug":"线程池线程复用的原理是什么","link":"#线程池线程复用的原理是什么","children":[]},{"level":2,"title":"如何预防死锁？","slug":"如何预防死锁","link":"#如何预防死锁","children":[]},{"level":2,"title":"描述一下线程安全活跃态问题？","slug":"描述一下线程安全活跃态问题","link":"#描述一下线程安全活跃态问题","children":[]},{"level":2,"title":"线程安全的竞态条件有哪些？","slug":"线程安全的竞态条件有哪些","link":"#线程安全的竞态条件有哪些","children":[]},{"level":2,"title":"程序开多少线程合适？","slug":"程序开多少线程合适","link":"#程序开多少线程合适","children":[]},{"level":2,"title":"synchronized和lock有哪些区别？","slug":"synchronized和lock有哪些区别","link":"#synchronized和lock有哪些区别","children":[]},{"level":2,"title":"ABA问题遇到过吗，详细说一下？","slug":"aba问题遇到过吗-详细说一下","link":"#aba问题遇到过吗-详细说一下","children":[]},{"level":2,"title":"volatile的可见性和禁止指令重排序怎么实现的？","slug":"volatile的可见性和禁止指令重排序怎么实现的","link":"#volatile的可见性和禁止指令重排序怎么实现的","children":[]},{"level":2,"title":"ConcurrentHashMap底层原理是什么？","slug":"concurrenthashmap底层原理是什么","link":"#concurrenthashmap底层原理是什么","children":[]},{"level":2,"title":"分布式id生成方案有哪些？","slug":"分布式id生成方案有哪些","link":"#分布式id生成方案有哪些","children":[]},{"level":2,"title":"雪花算法生成的ID由哪些部分组成?","slug":"雪花算法生成的id由哪些部分组成","link":"#雪花算法生成的id由哪些部分组成","children":[]},{"level":2,"title":"分布式锁在项目中有哪些应用场景？","slug":"分布式锁在项目中有哪些应用场景","link":"#分布式锁在项目中有哪些应用场景","children":[]},{"level":2,"title":"分布锁有哪些解决方案？","slug":"分布锁有哪些解决方案","link":"#分布锁有哪些解决方案","children":[]},{"level":2,"title":"Redis做分布式锁用什么命令？","slug":"redis做分布式锁用什么命令","link":"#redis做分布式锁用什么命令","children":[]},{"level":2,"title":"Redis做分布式锁死锁有哪些情况，如何解决？","slug":"redis做分布式锁死锁有哪些情况-如何解决","link":"#redis做分布式锁死锁有哪些情况-如何解决","children":[]},{"level":2,"title":"Redis如何做分布式锁？","slug":"redis如何做分布式锁","link":"#redis如何做分布式锁","children":[]},{"level":2,"title":"基于 ZooKeeper 的分布式锁实现原理是什么?","slug":"基于-zookeeper-的分布式锁实现原理是什么","link":"#基于-zookeeper-的分布式锁实现原理是什么","children":[]},{"level":2,"title":"ZooKeeper和Reids做分布式锁的区别？","slug":"zookeeper和reids做分布式锁的区别","link":"#zookeeper和reids做分布式锁的区别","children":[]},{"level":2,"title":"MySQL如何做分布式锁？","slug":"mysql如何做分布式锁","link":"#mysql如何做分布式锁","children":[]},{"level":2,"title":"计数器算法是什么？","slug":"计数器算法是什么","link":"#计数器算法是什么","children":[]},{"level":2,"title":"滑动时间窗口算法是什么？","slug":"滑动时间窗口算法是什么","link":"#滑动时间窗口算法是什么","children":[]},{"level":2,"title":"漏桶限流算法是什么？","slug":"漏桶限流算法是什么","link":"#漏桶限流算法是什么","children":[]},{"level":2,"title":"令牌桶限流算法是什么？","slug":"令牌桶限流算法是什么","link":"#令牌桶限流算法是什么","children":[]},{"level":2,"title":"你设计微服务时遵循什么原则？","slug":"你设计微服务时遵循什么原则","link":"#你设计微服务时遵循什么原则","children":[]},{"level":2,"title":"CAP定理是什么？","slug":"cap定理是什么","link":"#cap定理是什么","children":[]},{"level":2,"title":"BASE理论是什么？","slug":"base理论是什么","link":"#base理论是什么","children":[]},{"level":2,"title":"2PC提交协议是什么？","slug":"_2pc提交协议是什么","link":"#_2pc提交协议是什么","children":[]},{"level":2,"title":"2PC提交协议有什么缺点？","slug":"_2pc提交协议有什么缺点","link":"#_2pc提交协议有什么缺点","children":[]},{"level":2,"title":"3PC提交协议是什么？","slug":"_3pc提交协议是什么","link":"#_3pc提交协议是什么","children":[]},{"level":2,"title":"2PC和3PC的区别是什么？","slug":"_2pc和3pc的区别是什么","link":"#_2pc和3pc的区别是什么","children":[]},{"level":2,"title":"TCC空回滚是解决什么问题的？","slug":"tcc空回滚是解决什么问题的","link":"#tcc空回滚是解决什么问题的","children":[]},{"level":2,"title":"如何解决TCC幂等问题？","slug":"如何解决tcc幂等问题","link":"#如何解决tcc幂等问题","children":[]},{"level":2,"title":"如何解决TCC中悬挂问题？","slug":"如何解决tcc中悬挂问题","link":"#如何解决tcc中悬挂问题","children":[]},{"level":2,"title":"可靠消息服务方案是什么？","slug":"可靠消息服务方案是什么","link":"#可靠消息服务方案是什么","children":[]},{"level":2,"title":"最大努力通知方案的关键是什么？","slug":"最大努力通知方案的关键是什么","link":"#最大努力通知方案的关键是什么","children":[]},{"level":2,"title":"什么是分布式系统中的幂等？","slug":"什么是分布式系统中的幂等","link":"#什么是分布式系统中的幂等","children":[]},{"level":2,"title":"幂等有哪些技术解决方案？","slug":"幂等有哪些技术解决方案","link":"#幂等有哪些技术解决方案","children":[]},{"level":2,"title":"对外提供的API如何保证幂等？","slug":"对外提供的api如何保证幂等","link":"#对外提供的api如何保证幂等","children":[]},{"level":2,"title":"双写一致性问题如何解决？","slug":"双写一致性问题如何解决","link":"#双写一致性问题如何解决","children":[{"level":4,"title":"大前提：","slug":"大前提","link":"#大前提","children":[]},{"level":4,"title":"(1)先更新数据库，再更新缓存","slug":"_1-先更新数据库-再更新缓存","link":"#_1-先更新数据库-再更新缓存","children":[]},{"level":4,"title":"(2)先删缓存，再更新数据库","slug":"_2-先删缓存-再更新数据库","link":"#_2-先删缓存-再更新数据库","children":[]},{"level":4,"title":"(3)先更新数据库，再删缓存","slug":"_3-先更新数据库-再删缓存","link":"#_3-先更新数据库-再删缓存","children":[]}]},{"level":2,"title":"分布式微服务项目你是如何设计的？","slug":"分布式微服务项目你是如何设计的","link":"#分布式微服务项目你是如何设计的","children":[]},{"level":2,"title":"认证 (Authentication) 和授权 (Authorization)的区别是什么？","slug":"认证-authentication-和授权-authorization-的区别是什么","link":"#认证-authentication-和授权-authorization-的区别是什么","children":[]},{"level":2,"title":"Cookie 和 Session 有什么区别？如何使用Session进行身份验证？","slug":"cookie-和-session-有什么区别-如何使用session进行身份验证","link":"#cookie-和-session-有什么区别-如何使用session进行身份验证","children":[]},{"level":2,"title":"为什么Cookie 无法防止CSRF攻击，而token可以？","slug":"为什么cookie-无法防止csrf攻击-而token可以","link":"#为什么cookie-无法防止csrf攻击-而token可以","children":[]},{"level":2,"title":"什么是 Token?什么是 JWT?如何基于Token进行身份验证？","slug":"什么是-token-什么是-jwt-如何基于token进行身份验证","link":"#什么是-token-什么是-jwt-如何基于token进行身份验证","children":[]},{"level":2,"title":"分布式架构下，Session 共享有什么方案?","slug":"分布式架构下-session-共享有什么方案","link":"#分布式架构下-session-共享有什么方案","children":[]},{"level":2,"title":"springcloud核心组件有哪些？","slug":"springcloud核心组件有哪些","link":"#springcloud核心组件有哪些","children":[]},{"level":2,"title":"微服务架构原理是什么？","slug":"微服务架构原理是什么","link":"#微服务架构原理是什么","children":[]},{"level":2,"title":"注册中心的原理是什么？","slug":"注册中心的原理是什么","link":"#注册中心的原理是什么","children":[]},{"level":2,"title":"配置中心的原理是什么？","slug":"配置中心的原理是什么","link":"#配置中心的原理是什么","children":[]},{"level":2,"title":"配置中心是如何实现自动刷新的？","slug":"配置中心是如何实现自动刷新的","link":"#配置中心是如何实现自动刷新的","children":[]},{"level":2,"title":"配置中心是如何保证数据安全的?","slug":"配置中心是如何保证数据安全的","link":"#配置中心是如何保证数据安全的","children":[]},{"level":2,"title":"用zookeeper和eureka做注册中心有什么区别?","slug":"用zookeeper和eureka做注册中心有什么区别","link":"#用zookeeper和eureka做注册中心有什么区别","children":[]},{"level":2,"title":"Spring Cloud和Dubbo有哪些区别?","slug":"spring-cloud和dubbo有哪些区别","link":"#spring-cloud和dubbo有哪些区别","children":[]},{"level":2,"title":"Ribbon负载均衡原理是什么?","slug":"ribbon负载均衡原理是什么","link":"#ribbon负载均衡原理是什么","children":[]},{"level":2,"title":"微服务熔断降级机制是什么?","slug":"微服务熔断降级机制是什么","link":"#微服务熔断降级机制是什么","children":[]},{"level":2,"title":"什么是Hystrix？实现原理是什么?","slug":"什么是hystrix-实现原理是什么","link":"#什么是hystrix-实现原理是什么","children":[]},{"level":2,"title":"注册中心挂了，或者服务挂了，应该如何处理?","slug":"注册中心挂了-或者服务挂了-应该如何处理","link":"#注册中心挂了-或者服务挂了-应该如何处理","children":[]},{"level":2,"title":"说说你对RPC、RMI如何理解?","slug":"说说你对rpc、rmi如何理解","link":"#说说你对rpc、rmi如何理解","children":[]},{"level":2,"title":"redis持久化机制：RDB和AOF","slug":"redis持久化机制-rdb和aof","link":"#redis持久化机制-rdb和aof","children":[{"level":3,"title":"Redis 持久化","slug":"redis-持久化","link":"#redis-持久化","children":[]},{"level":3,"title":"RDB的优点","slug":"rdb的优点","link":"#rdb的优点","children":[]},{"level":3,"title":"RDB的缺点","slug":"rdb的缺点","link":"#rdb的缺点","children":[]},{"level":3,"title":"AOF 优点","slug":"aof-优点","link":"#aof-优点","children":[]},{"level":3,"title":"AOF 缺点","slug":"aof-缺点","link":"#aof-缺点","children":[]},{"level":3,"title":"4.X版本的整合策略","slug":"_4-x版本的整合策略","link":"#_4-x版本的整合策略","children":[]},{"level":3,"title":"扩展知识","slug":"扩展知识","link":"#扩展知识","children":[]}]},{"level":2,"title":"redis的过期键有哪些删除策略","slug":"redis的过期键有哪些删除策略","link":"#redis的过期键有哪些删除策略","children":[{"level":3,"title":"过期精度","slug":"过期精度","link":"#过期精度","children":[]},{"level":3,"title":"过期和持久","slug":"过期和持久","link":"#过期和持久","children":[]},{"level":3,"title":"Redis如何淘汰过期的keys","slug":"redis如何淘汰过期的keys","link":"#redis如何淘汰过期的keys","children":[]},{"level":3,"title":"在复制AOF文件时如何处理过期","slug":"在复制aof文件时如何处理过期","link":"#在复制aof文件时如何处理过期","children":[]},{"level":3,"title":"扩展","slug":"扩展","link":"#扩展","children":[]}]},{"level":2,"title":"redis线程模型有哪些，单线程为什么快","slug":"redis线程模型有哪些-单线程为什么快","link":"#redis线程模型有哪些-单线程为什么快","children":[{"level":3,"title":"IO模型维度的特征","slug":"io模型维度的特征","link":"#io模型维度的特征","children":[]},{"level":3,"title":"架构设计模型","slug":"架构设计模型","link":"#架构设计模型","children":[]}]},{"level":2,"title":"缓存雪崩、缓存穿透、缓存击穿在实际中如何处理","slug":"缓存雪崩、缓存穿透、缓存击穿在实际中如何处理","link":"#缓存雪崩、缓存穿透、缓存击穿在实际中如何处理","children":[{"level":3,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[{"level":4,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]}]},{"level":3,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[{"level":4,"title":"解决方案","slug":"解决方案-1","link":"#解决方案-1","children":[]}]},{"level":3,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[{"level":4,"title":"解决方案","slug":"解决方案-2","link":"#解决方案-2","children":[]}]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"redis事务是怎么实现的","slug":"redis事务是怎么实现的","link":"#redis事务是怎么实现的","children":[{"level":3,"title":"事务中的错误","slug":"事务中的错误","link":"#事务中的错误","children":[]},{"level":3,"title":"为什么 Redis 不支持回滚（roll back）","slug":"为什么-redis-不支持回滚-roll-back","link":"#为什么-redis-不支持回滚-roll-back","children":[]}]},{"level":2,"title":"redis集群方案有哪些","slug":"redis集群方案有哪些","link":"#redis集群方案有哪些","children":[{"level":3,"title":"常见集群分类","slug":"常见集群分类","link":"#常见集群分类","children":[]},{"level":3,"title":"redis有那些：","slug":"redis有那些","link":"#redis有那些","children":[]}]},{"level":2,"title":"redis主从复制的原理是什么","slug":"redis主从复制的原理是什么","link":"#redis主从复制的原理是什么","children":[{"level":3,"title":"主从复制机制","slug":"主从复制机制","link":"#主从复制机制","children":[]},{"level":3,"title":"主从复制的关注点","slug":"主从复制的关注点","link":"#主从复制的关注点","children":[]},{"level":3,"title":"Redis 复制功能是如何工作的","slug":"redis-复制功能是如何工作的","link":"#redis-复制功能是如何工作的","children":[]},{"level":3,"title":"无需磁盘参与的复制","slug":"无需磁盘参与的复制","link":"#无需磁盘参与的复制","children":[]}]},{"level":2,"title":"redis缓存如何回收","slug":"redis缓存如何回收","link":"#redis缓存如何回收","children":[{"level":3,"title":"回收策略","slug":"回收策略","link":"#回收策略","children":[]},{"level":3,"title":"回收进程如何工作","slug":"回收进程如何工作","link":"#回收进程如何工作","children":[]}]},{"level":2,"title":"RabbitMQ的架构设计是什么样的","slug":"rabbitmq的架构设计是什么样的","link":"#rabbitmq的架构设计是什么样的","children":[{"level":3,"title":"是AMQP的实现，相关概念语义","slug":"是amqp的实现-相关概念语义","link":"#是amqp的实现-相关概念语义","children":[{"level":4,"title":"核心概念","slug":"核心概念","link":"#核心概念","children":[]},{"level":4,"title":"Exchange","slug":"exchange","link":"#exchange","children":[]}]},{"level":3,"title":"复杂与精简","slug":"复杂与精简","link":"#复杂与精简","children":[]}]},{"level":2,"title":"RabbitMQ如何确保消息发送和消息接收","slug":"rabbitmq如何确保消息发送和消息接收","link":"#rabbitmq如何确保消息发送和消息接收","children":[{"level":3,"title":"消息发送确认","slug":"消息发送确认","link":"#消息发送确认","children":[{"level":4,"title":"1 ConfirmCallback方法","slug":"_1-confirmcallback方法","link":"#_1-confirmcallback方法","children":[]},{"level":4,"title":"2 ReturnCallback方法","slug":"_2-returncallback方法","link":"#_2-returncallback方法","children":[]}]},{"level":3,"title":"消息接收确认","slug":"消息接收确认","link":"#消息接收确认","children":[]}]},{"level":2,"title":"RabbitMQ事务消息原理是什么","slug":"rabbitmq事务消息原理是什么","link":"#rabbitmq事务消息原理是什么","children":[{"level":3,"title":"事务V.S确认","slug":"事务v-s确认","link":"#事务v-s确认","children":[]},{"level":3,"title":"发送方事务","slug":"发送方事务","link":"#发送方事务","children":[]},{"level":3,"title":"消费方事务","slug":"消费方事务","link":"#消费方事务","children":[]}]},{"level":2,"title":"RabbitMQ死信队列、延时队列分别是什么","slug":"rabbitmq死信队列、延时队列分别是什么","link":"#rabbitmq死信队列、延时队列分别是什么","children":[{"level":3,"title":"死信队列","slug":"死信队列","link":"#死信队列","children":[{"level":4,"title":"过期消息：","slug":"过期消息","link":"#过期消息","children":[]}]},{"level":3,"title":"延迟队列","slug":"延迟队列","link":"#延迟队列","children":[]}]},{"level":2,"title":"简述kafka架构设计是什么样","slug":"简述kafka架构设计是什么样","link":"#简述kafka架构设计是什么样","children":[]},{"level":2,"title":"Kafka消息丢失的场景有哪些","slug":"kafka消息丢失的场景有哪些","link":"#kafka消息丢失的场景有哪些","children":[{"level":3,"title":"ACK机制","slug":"ack机制","link":"#ack机制","children":[]},{"level":3,"title":"ack=0：生产者在生产过程中的消息丢失","slug":"ack-0-生产者在生产过程中的消息丢失","link":"#ack-0-生产者在生产过程中的消息丢失","children":[]},{"level":3,"title":"ack=1：broker在故障后的消息丢失","slug":"ack-1-broker在故障后的消息丢失","link":"#ack-1-broker在故障后的消息丢失","children":[]},{"level":3,"title":"ack=-1：生产侧和存储侧不会丢失数据","slug":"ack-1-生产侧和存储侧不会丢失数据","link":"#ack-1-生产侧和存储侧不会丢失数据","children":[]},{"level":3,"title":"Offset机制","slug":"offset机制","link":"#offset机制","children":[]}]},{"level":2,"title":"Kafka是pull？push？以及优劣势分析","slug":"kafka是pull-push-以及优劣势分析","link":"#kafka是pull-push-以及优劣势分析","children":[]},{"level":2,"title":"Kafka中zk的作用是什么","slug":"kafka中zk的作用是什么","link":"#kafka中zk的作用是什么","children":[]},{"level":2,"title":"Kafka中高性能如何保障","slug":"kafka中高性能如何保障","link":"#kafka中高性能如何保障","children":[]},{"level":2,"title":"kafka的rebalance机制是什么","slug":"kafka的rebalance机制是什么","link":"#kafka的rebalance机制是什么","children":[{"level":3,"title":"消费者分区分配策略","slug":"消费者分区分配策略","link":"#消费者分区分配策略","children":[]},{"level":3,"title":"触发 Rebalance 的时机","slug":"触发-rebalance-的时机","link":"#触发-rebalance-的时机","children":[]},{"level":3,"title":"Coordinator协调过程","slug":"coordinator协调过程","link":"#coordinator协调过程","children":[]}]},{"level":2,"title":"zk的数据模型和节点类型有哪些","slug":"zk的数据模型和节点类型有哪些","link":"#zk的数据模型和节点类型有哪些","children":[{"level":3,"title":"ZooKeeper数据模型","slug":"zookeeper数据模型","link":"#zookeeper数据模型","children":[]},{"level":3,"title":"节点类型","slug":"节点类型","link":"#节点类型","children":[]}]},{"level":2,"title":"Zookeeper watch机制是什么","slug":"zookeeper-watch机制是什么","link":"#zookeeper-watch机制是什么","children":[{"level":3,"title":"ZooKeeper的Watch特性","slug":"zookeeper的watch特性","link":"#zookeeper的watch特性","children":[]},{"level":3,"title":"Zookeeper状态","slug":"zookeeper状态","link":"#zookeeper状态","children":[]},{"level":3,"title":"Zookeeper事件类型","slug":"zookeeper事件类型","link":"#zookeeper事件类型","children":[]},{"level":3,"title":"Watcher使用的注意事项","slug":"watcher使用的注意事项","link":"#watcher使用的注意事项","children":[]}]},{"level":2,"title":"zk的命名服务、配置管理、集群管理分别是什么","slug":"zk的命名服务、配置管理、集群管理分别是什么","link":"#zk的命名服务、配置管理、集群管理分别是什么","children":[{"level":3,"title":"分布式协调","slug":"分布式协调","link":"#分布式协调","children":[]},{"level":3,"title":"命名服务","slug":"命名服务","link":"#命名服务","children":[]},{"level":3,"title":"配置管理","slug":"配置管理","link":"#配置管理","children":[]},{"level":3,"title":"集群管理","slug":"集群管理","link":"#集群管理","children":[]}]}],"git":{"createdTime":1671170523000,"updatedTime":1671170523000,"contributors":[{"name":"jinfang","email":"topjfk@163.com","commits":1}]},"readingTime":{"minutes":274.27,"words":82281},"filePathRelative":"all/interview.md","localizedDate":"2022年7月21日","excerpt":"","autoDesc":true}');export{l as data};
